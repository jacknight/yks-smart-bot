const unsplash = require("unsplash-js");
const nodeFetch = require("node-fetch");

exports.unsplash = unsplash.createApi({
  accessKey: process.env.UNSPLASH_ACCESS_KEY,
  fetch: nodeFetch.default,
});

exports.shuffle = (array) => {
  var currentIndex = array.length,
    temporaryValue,
    randomIndex;

  while (0 !== currentIndex) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
};

exports.getRealKickstarters = async () => {
  const fs = require("fs");
  const readline = require("readline");
  const { once } = require("events");
  const responses = [];
  // Grab from file of real kickstarters
  const rl = readline.createInterface({
    input: fs.createReadStream("assets/PromptCompletion_prepared.jsonl"),
    crlfDelay: Infinity,
  });

  rl.on("error", (err) => console.error(err));

  rl.on("line", (line) => {
    if (!line) return;

    // Add completion to responses array.
    let temp = { data: { choices: [{ text: JSON.parse(line).completion }] } };
    responses.push(temp);
  });

  await once(rl, "close");

  return responses;
};

exports.sleep = (ms) => {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
};

exports.sendRequest = async (url, method, opts = {}) => {
  const axios = require("axios");
  let camelToUnderscore = (key) => {
    let result = key.replace(/([A-Z])/g, " $1");
    return result.split(" ").join("_").toLowerCase();
  };

  const data = {};
  for (const key in opts) {
    data[camelToUnderscore(key)] = opts[key];
  }

  return axios({
    url,
    headers: {
      Authorization: `Bearer ${process.env.OPENAI_KEY}`,
      "Content-Type": "application/json",
    },
    data: Object.keys(data).length ? data : "",
    method,
  });
};

exports.getAIResponse = async (name, userID) => {
  try {
    const response = await exports.sendRequest(
      "https://api.openai.com/v1/completions",
      "post",
      {
        prompt: `**Name**: ${name}`,
        model: "curie:ft-yks-smart-bot-2021-08-07-18-00-06",
        maxTokens: 350,
        temperature: 0.8,
        topP: 1,
        presencePenalty: 0,
        frequencyPenalty: 0,
        bestOf: 1,
        n: 1,
        stream: false,
        stop: ["###"],
        echo: true,
        user: userID,
      }
    );
    return response;
  } catch (e) {
    if (e.response) {
      return `(OpenAI Error) ${e.response.statusText}`;
    }
    console.log(e);
  }
};

exports.getKickstarterEmbed = (completion, realOrFake) => {
  const title = completion.match(/\*\*Name\*\*: (.*)/);
  const category = completion.match(/\*\*Category\*\*: (.*)/);
  const status = completion.match(/\*\*Status\*\*: (.*)/);
  const backers = completion.match(/\*\*Backers\*\*: (.*)/);
  const pledged = completion.match(/\*\*Pledged\*\*: (.*)/);
  const goal = completion.match(/\*\*Goal\*\*: (.*)/);
  const author = completion.match(/\*\*Creator\*\*: (.*)/);
  const description = completion.match(/\*\*Description\*\*: (.*)/);
  if (
    title &&
    category &&
    status &&
    backers &&
    pledged &&
    goal &&
    author &&
    description
  ) {
    return {
      color:
        status[1] === "successful"
          ? 0x83c133
          : status[1] === "failed" || status[1] === "canceled"
          ? 0xff0000
          : 0x0000ff,
      title: title[1],
      description: description[1],
      fields: [
        {
          name: "Creator",
          value: author[1],
          inline: false,
        },
        {
          name: "Category",
          value: category[1],
          inline: false,
        },
        {
          name: "Backers",
          value: backers[1],
          inline: true,
        },
        {
          name: "Pledged",
          value: pledged[1],
          inline: true,
        },
        {
          name: "Goal",
          value: goal[1],
          inline: true,
        },
        {
          name: "Status",
          value: status[1],
        },
      ],
      footer: {
        text: `Output generated by GPT-3${realOrFake ? " (maybe)" : ""}`,
      },
    };
  } else {
    return null;
  }
};

exports.undoRateLimit = (client, userID, commandID) => {
  const userCooldown = client.commandHandler.cooldowns.get(userID);
  if (userCooldown) {
    const userCommandCooldown = userCooldown[commandID];
    if (userCommandCooldown) {
      userCommandCooldown.uses--;
      client.commandHandler.cooldowns.get(userID)[commandID] =
        userCommandCooldown;
    }
  }
};
